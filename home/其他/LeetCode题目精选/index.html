
<!DOCTYPE html>

<html class="no-js" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../../../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.4.0, mkdocs-material-8.5.6" name="generator"/>
<title>LeetCode题目精选 - 大数据成神之路</title>
<link href="../../../assets/stylesheets/main.20d9efc8.min.css" rel="stylesheet"/>
<link href="../../../assets/stylesheets/palette.cbb835fc.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<link href="../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
            html.glightbox-open { overflow: initial; height: 100%; }
            .gdesc-inner { font-size: 0.75rem; }
            .gslide-title { margin-top: 0px; user-select: text; }
            .gslide-desc { color: #666; user-select: text; }
            .gslide-image img { background: white; }
            
                .gscrollbar-fixer { padding-right: 15px; }
                </style><script src="../../../assets/javascripts/glightbox.min.js"></script></head>
<body data-md-color-accent="" data-md-color-primary="orange" data-md-color-scheme="default" dir="ltr">
<script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#leetcode">
          Skip to content
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="Header" class="md-header__inner md-grid">
<a aria-label="大数据成神之路" class="md-header__button md-logo" data-md-component="logo" href="../../.." title="大数据成神之路">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            大数据成神之路
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              LeetCode题目精选
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Switch to dark mode" class="md-option" data-md-color-accent="" data-md-color-media="(prefers-color-scheme: light)" data-md-color-primary="orange" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_2" hidden="" title="Switch to dark mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"></path></svg>
</label>
<input aria-label="Switch to light mode" class="md-option" data-md-color-accent="blue-grey" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-primary="black" data-md-color-scheme="slate" id="__palette_2" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Switch to light mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"></path></svg>
</label>
</form>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/maomao199691/Python_Code.git" title="Go to repository">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    maomao199691/Python_Code
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Navigation" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="大数据成神之路" class="md-nav__button md-logo" data-md-component="logo" href="../../.." title="大数据成神之路">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"></path></svg>
</a>
    大数据成神之路
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/maomao199691/Python_Code.git" title="Go to repository">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    maomao199691/Python_Code
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" data-md-toggle="__nav_1" id="__nav_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_1">
          Home
          <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="Home" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_1">
<span class="md-nav__icon md-icon"></span>
          Home
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../..">
        大数据技术之高频面试题
      </a>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" data-md-toggle="__nav_1_2" id="__nav_1_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_1_2">
          项目涉及技术
          <span class="md-nav__icon md-icon"></span>
</label>
<nav aria-label="项目涉及技术" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_1_2">
<span class="md-nav__icon md-icon"></span>
          项目涉及技术
        </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Linux%26Shell/">
        Linux&amp;Shell
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/JavaSE/">
        JavaSE
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Hadoop/">
        Hadoop
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Zookeeper/">
        Zookeeper
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Flume/">
        Flume
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Kafka/">
        Kafka
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Hive/">
        Hive
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Datax/">
        Datax
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Maxwell/">
        Maxwell
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/DolphinScheduler/">
        DolphinScheduler
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Scala/">
        Scala
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/SparkCore%26SQL/">
        Spark Core&amp;SQL
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/SparkStreaming/">
        Spark Streaming
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/%E6%95%B0%E6%8D%AE%E5%80%BE%E6%96%9C/">
        数据倾斜
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Flink/">
        Flink
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Flink%E5%AE%9E%E6%97%B6%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/">
        Flink实时项目优化
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/HBase/">
        HBase
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/ClickHouse/">
        ClickHouse
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Sqoop/">
        Sqoop
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../../%E9%A1%B9%E7%9B%AE%E6%B6%89%E5%8F%8A%E6%8A%80%E6%9C%AF/Azkaban/">
        Azkaban
      </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/">
        数仓架构
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/">
        数仓建模
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E4%B8%9A%E5%8A%A1/">
        生产经验—业务
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E6%B5%8B%E8%AF%95%E4%B8%8A%E7%BA%BF%E7%9B%B8%E5%85%B3/">
        生产经验--测试上线相关
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E6%8A%80%E6%9C%AF/">
        生产经验—技术
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E7%94%9F%E4%BA%A7%E7%BB%8F%E9%AA%8C%E2%80%94%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98/">
        生产经验—热点问题
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/">
        数据质量
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E5%AE%9E%E6%97%B6%E6%95%B0%E4%BB%93%E9%A1%B9%E7%9B%AE/">
        实时数仓项目
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../JavaSE/">
        JavaSE
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../Redis/">
        Redis
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../MySql/">
        MySql
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../JVM/">
        JVM
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../JUC/">
        JUC
      </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E9%9D%A2%E8%AF%95%E8%AF%B4%E6%98%8E/">
        面试说明
      </a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" data-md-toggle="toc" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
          LeetCode题目精选
          <span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="./">
        LeetCode题目精选
      </a>
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    基本算法
  </a>
<nav aria-label="基本算法" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    冒泡排序
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    二分查找
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    归并
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#scala">
    二叉树之Scala实现
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_5">
    两数之和
  </a>
<nav aria-label="两数之和" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
    爬楼梯
  </a>
<nav aria-label="爬楼梯" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
    翻转二叉树
  </a>
<nav aria-label="翻转二叉树" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#155">
    15.5 反转链表
  </a>
<nav aria-label="15.5 反转链表" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_13">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_14">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lru">
    LRU缓存机制
  </a>
<nav aria-label="LRU缓存机制" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
    最长回文子串
  </a>
<nav aria-label="最长回文子串" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
    有效的括号
  </a>
<nav aria-label="有效的括号" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_22">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#k">
    数组中的第K个最大元素
  </a>
<nav aria-label="数组中的第K个最大元素" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trie">
    实现 Trie (前缀树)
  </a>
<nav aria-label="实现 Trie (前缀树)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_25">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_26">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_27">
    编辑距离
  </a>
<nav aria-label="编辑距离" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_28">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_29">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="../%E6%89%8B%E5%86%99HQL%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/">
        手写HQL题目练习
      </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="Table of contents" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
    基本算法
  </a>
<nav aria-label="基本算法" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
    冒泡排序
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
    二分查找
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
    归并
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#scala">
    二叉树之Scala实现
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_5">
    两数之和
  </a>
<nav aria-label="两数之和" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
    爬楼梯
  </a>
<nav aria-label="爬楼梯" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#1">
    1问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
    翻转二叉树
  </a>
<nav aria-label="翻转二叉树" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#155">
    15.5 反转链表
  </a>
<nav aria-label="15.5 反转链表" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_13">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_14">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lru">
    LRU缓存机制
  </a>
<nav aria-label="LRU缓存机制" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
    最长回文子串
  </a>
<nav aria-label="最长回文子串" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
    有效的括号
  </a>
<nav aria-label="有效的括号" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_22">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#k">
    数组中的第K个最大元素
  </a>
<nav aria-label="数组中的第K个最大元素" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#trie">
    实现 Trie (前缀树)
  </a>
<nav aria-label="实现 Trie (前缀树)" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_25">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_26">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_27">
    编辑距离
  </a>
<nav aria-label="编辑距离" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_28">
    问题描述
  </a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_29">
    参考答案
  </a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<a class="md-content__button md-icon" href="https://github.com/maomao199691/Python_Code.git/edit/master/docs/home/其他/LeetCode题目精选.md" title="Edit this page">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25Z"></path></svg>
</a>
<hr/>
<h1 id="leetcode">LeetCode题目精选</h1>
<h2 id="_1">基本算法</h2>
<h3 id="_2">冒泡排序</h3>
<pre><code class="language-java">/**
 * 冒泡排序 时间复杂度 O(n^2) 空间复杂度O(1)
 */
public class BubbleSort {

   public static void bubbleSort(int[] data) {

      System.out.println("开始排序");
      int arrayLength = data.length;

      for (int i = 0; i &lt; arrayLength - 1; i++) {

         boolean flag = false;

         for (int j = 0; j &lt; arrayLength - 1 - i; j++) {
            if(data[j] &gt; data[j + 1]){
               int temp = data[j + 1];
               data[j + 1] = data[j];
               data[j] = temp;
               flag = true;
            }
         }

         System.out.println(java.util.Arrays.toString(data));

         if (!flag)
            break;
      }
   }

   public static void main(String[] args) {

      int[] data = { 9, -16, 21, 23, -30, -49, 21, 30, 30 };

      System.out.println("排序之前：\n" + java.util.Arrays.toString(data));

      bubbleSort(data);

      System.out.println("排序之后：\n" + java.util.Arrays.toString(data));
   }
}
</code></pre>
<h3 id="_3">二分查找</h3>
<p><center><strong>二分查找核心思路</strong></center></p>
<p><a class="glightbox" data-desc-position="bottom" data-description="" data-height="auto" data-title="" data-width="100%" href="https://i.postimg.cc/P5BwvFY9/image.png"><img alt="trigger" src="https://i.postimg.cc/P5BwvFY9/image.png" width="width"/></a></p>
<p>实现代码：</p>
<pre><code class="language-java">/**
 * 二分查找 时间复杂度O(log2n);空间复杂度O(1)
 */

def binarySearch(arr:Array[Int],left:Int,right:Int,findVal:Int): Int={
  if(left&gt;right){//递归退出条件，找不到，返回-1
    -1
  }

  val midIndex = (left+right)/2

  if (findVal &lt; arr(midIndex)){//向左递归查找
    binarySearch(arr,left,midIndex-1,findVal)
  }else if(findVal &gt; arr(midIndex)){//向右递归查找
    binarySearch(arr,midIndex+1,right,findVal)
  }else{//查找到，返回下标
    midIndex
  }
}
</code></pre>
<p>拓展需求：当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到。</p>
<p>代码实现如下：</p>
<pre><code class="language-java">/*
  {1,8, 10, 89, 1000, 1000，1234} 当一个有序数组中，有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000.
  //分析
  1. 返回的结果是一个可变数组 ArrayBuffer
  2. 在找到结果时，向左边扫描，向右边扫描 [条件]
  3. 找到结果后，就加入到ArrayBuffer
   */
  def binarySearch2(arr: Array[Int], l: Int, r: Int,
                    findVal: Int): ArrayBuffer[Int] = {

    //找不到条件?
    if (l &gt; r) {
      return ArrayBuffer()
    }

    val midIndex = (l + r) / 2
    val midVal = arr(midIndex)
    if (midVal &gt; findVal) {
      //向左进行递归查找
      binarySearch2(arr, l, midIndex - 1, findVal)
    } else if (midVal &lt; findVal) { //向右进行递归查找
      binarySearch2(arr, midIndex + 1, r, findVal)
    } else {
      println("midIndex=" + midIndex)
      //定义一个可变数组
      val resArr = ArrayBuffer[Int]()
      //向左边扫描
      var temp = midIndex - 1
      breakable {
        while (true) {
          if (temp &lt; 0 || arr(temp) != findVal) {
            break()
          }
          if (arr(temp) == findVal) {
            resArr.append(temp)
          }
          temp -= 1
        }
      }
      //将中间这个索引加入
      resArr.append(midIndex)
      //向右边扫描
      temp = midIndex + 1
      breakable {
        while (true) {
          if (temp &gt; arr.length - 1 || arr(temp) != findVal) {
            break()
          }
          if (arr(temp) == findVal) {
            resArr.append(temp)
          }
          temp += 1
        }
      }
      return resArr
    }
</code></pre>
<p><center><strong>快速排序核心思想</strong></center></p>
<p><a class="glightbox" data-desc-position="bottom" data-description="" data-height="auto" data-title="" data-width="100%" href="https://i.postimg.cc/HxjnSwwX/image.png"><img alt="trigger" src="https://i.postimg.cc/HxjnSwwX/image.png" width="width"/></a></p>
<p>代码实现：</p>
<pre><code class="language-java">/**
 * 快排
 * 时间复杂度:平均时间复杂度为O(nlogn)
 * 空间复杂度:O(logn)，因为递归栈空间的使用问题
 */
def quickSort(list: List[Int]): List[Int] = list match {
    case Nil =&gt; Nil
    case List() =&gt; List()
    case head :: tail =&gt;
      val (left, right) = tail.partition(_ &lt; head)
      quickSort(left) ::: head :: quickSort(right)
  }
</code></pre>
<h3 id="_4">归并</h3>
<p><center><strong>归并排序核心思想</strong></center></p>
<p><a class="glightbox" data-desc-position="bottom" data-description="" data-height="auto" data-title="" data-width="100%" href="https://i.postimg.cc/wj8ztS0S/image.png"><img alt="trigger" src="https://i.postimg.cc/wj8ztS0S/image.png" width="width"/></a></p>
<p>核心思想：不断的将大的数组分成两个小数组，直到不能拆分为止，即形成了单个值。此时使用合并的排序思想对已经有序的数组进行合并，合并为一个大的数据，不断重复此过程，直到最终所有数据合并到一个数组为止。
<center><strong>归并排序“治”流程</strong></center></p>
<p><a class="glightbox" data-desc-position="bottom" data-description="" data-height="auto" data-title="" data-width="100%" href="https://i.postimg.cc/wj8ztS0S/image.png"><img alt="trigger" src="https://i.postimg.cc/wj8ztS0S/image.png" width="width"/></a></p>
<p>代码实现：</p>
<pre><code class="language-java">/**
 * 快排 
 * 时间复杂度:O(nlogn)
 * 空间复杂度:O(n)
 */
def merge(left: List[Int], right: List[Int]): List[Int] = (left, right) match {
    case (Nil, _) =&gt; right
    case (_, Nil) =&gt; left
    case (x :: xTail, y :: yTail) =&gt;
      if (x &lt;= y) x :: merge(xTail, right)
      else y :: merge(left, yTail)
  }
</code></pre>
<h3 id="scala">二叉树之Scala实现</h3>
<p>1）二叉树概念
<center><strong>二叉树概念</strong></center></p>
<p><a class="glightbox" data-desc-position="bottom" data-description="" data-height="auto" data-title="" data-width="100%" href="https://i.postimg.cc/65n9WWtk/image.png"><img alt="trigger" src="https://i.postimg.cc/65n9WWtk/image.png" width="width"/></a></p>
<p>2）二叉树的特点</p>
<p>（1）树执行查找、删除、插入的时间复杂度都是O(logN)</p>
<p>（2）遍历二叉树的方法包括前序、中序、后序</p>
<p>（3）非平衡树指的是根的左右两边的子节点的数量不一致</p>
<p>（4）在非空二叉树中，第i层的结点总数不超过 , i&gt;=1；</p>
<p>（5）深度为h的二叉树最多有个结点(h&gt;=1)，最少有h个结点；</p>
<p>（6）对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；</p>
<p>3） 二叉树的Scala代码实现</p>
<p>定义节点以及前序、中序、后序遍历</p>
<pre><code class="language-java">class TreeNode(treeNo:Int){

  val no = treeNo
  var left:TreeNode = null
  var right:TreeNode = null

  //后序遍历
  def postOrder():Unit={
    //向左递归输出左子树
    if(this.left != null){
      this.left.postOrder
    }
    //向右递归输出右子树
    if (this.right != null) {
      this.right.postOrder
    }

    //输出当前节点值
    printf("节点信息 no=%d \n",no)
  }

  //中序遍历
  def infixOrder():Unit={
    //向左递归输出左子树
    if(this.left != null){
      this.left.infixOrder()
    }

    //输出当前节点值
    printf("节点信息 no=%d \n",no)

    //向右递归输出右子树
    if (this.right != null) {
      this.right.infixOrder()
    }
  }

  //前序遍历
  def preOrder():Unit={
    //输出当前节点值
    printf("节点信息 no=%d \n",no)

    //向左递归输出左子树
    if(this.left != null){
      this.left.postOrder()
    }

    //向右递归输出右子树
    if (this.right != null) {
      this.right.preOrder()
    }
  }

  //后序遍历查找
  def postOrderSearch(no:Int): TreeNode = {
    //向左递归输出左子树
    var resNode:TreeNode = null
    if (this.left != null) {
      resNode = this.left.postOrderSearch(no)
    }
    if (resNode != null) {
      return resNode
    }
    if (this.right != null) {
      resNode = this.right.postOrderSearch(no)
    }
    if (resNode != null) {
      return resNode
    }
    println("ttt~~")
    if (this.no == no) {
      return this
    }
    resNode
  }

  //中序遍历查找
  def infixOrderSearch(no:Int): TreeNode = {


    var resNode : TreeNode = null
    //先向左递归查找
    if (this.left != null) {
      resNode = this.left.infixOrderSearch(no)
    }
    if (resNode != null) {
      return resNode
    }
    println("yyy~~")
    if (no == this.no) {
      return this
    }
    //向右递归查找
    if (this.right != null) {
      resNode = this.right.infixOrderSearch(no)
    }
    return resNode

  }

  //前序查找
  def preOrderSearch(no:Int): TreeNode = {
    if (no == this.no) {
      return this
    }
    //向左递归查找
    var resNode : TreeNode = null
    if (this.left != null) {
      resNode = this.left.preOrderSearch(no)
    }
    if (resNode != null){
      return  resNode
    }
    //向右边递归查找
    if (this.right != null) {
      resNode = this.right.preOrderSearch(no)
    }

    return resNode
  }

  //删除节点
  //删除节点规则
  //1如果删除的节点是叶子节点，则删除该节点
  //2如果删除的节点是非叶子节点，则删除该子树

  def delNode(no:Int): Unit = {
    //首先比较当前节点的左子节点是否为要删除的节点
    if (this.left != null &amp;&amp; this.left.no == no) {
      this.left = null
      return
    }
    //比较当前节点的右子节点是否为要删除的节点
    if (this.right != null &amp;&amp; this.right.no == no) {
      this.right = null
      return
    }
    //向左递归删除
    if (this.left != null) {
      this.left.delNode(no)
    }
    //向右递归删除
    if (this.right != null) {
      this.right.delNode(no)
    }
  }
}
</code></pre>
<p>定义二叉树，前序、中序、后序遍历，前序、中序、后序查找，删除节点</p>
<pre><code class="language-java">class BinaryTree{
  var root:TreeNode = null

  //后序遍历
  def postOrder(): Unit = {
    if (root != null){
      root.postOrder()
    }else {
      println("当前二叉树为空，不能遍历")
}
}
    //中序遍历
    def infixOrder(): Unit = {
      if (root != null){
        root.infixOrder()
      }else {
        println("当前二叉树为空，不能遍历")
      }
    }
    //前序遍历
    def preOrder(): Unit = {
      if (root != null){
        root.preOrder()
      }else {
        println("当前二叉树为空，不能遍历")
      }
    }

    //后序遍历查找
    def postOrderSearch(no:Int): TreeNode = {
      if (root != null) {
        root.postOrderSearch(no)
      }else{
        null
      }
    }

    //中序遍历查找
    def infixOrderSeacher(no:Int): TreeNode = {
      if (root != null) {
        return root.infixOrderSearch(no)
      }else {
        return null
      }
    }

    //前序查找
    def preOrderSearch(no:Int): TreeNode = {

      if (root != null) {
        return root.preOrderSearch(no)
      }else{
        //println("当前二叉树为空，不能查找")
        return null
      }
    }
//删除节点
    def delNode(no:Int): Unit = {
      if (root != null) {
        //先处理一下root是不是要删除的
        if (root.no == no){
          root = null
        }else {
          root.delNode(no)
        }
      }

  }
</code></pre>
<p><a href="https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa">https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/xue-xi-shu-ju-jie-gou-he-suan-fa-de-gao-xiao-fang-fa</a></p>
<h2 id="_5">两数之和</h2>
<p>问题链接：https://leetcode-cn.com/problems/two-sum/</p>
<h3 id="_6">问题描述</h3>
<p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<pre><code>给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
</code></pre>
<h3 id="_7">参考答案</h3>
<pre><code class="language-java">java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        throw new IllegalArgumentException("No two sum solution");
    }
}
</code></pre>
<h2 id="_8">爬楼梯</h2>
<p>问题链接：https://leetcode-cn.com/problems/climbing-stairs/</p>
<h3 id="1">1问题描述</h3>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数。</p>
<p>示例 1：</p>
<pre><code class="language-java">输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
</code></pre>
<p>示例 2：</p>
<pre><code class="language-java">输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 += 1 阶
</code></pre>
<h3 id="_9">参考答案</h3>
<pre><code class="language-java">java
public class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
</code></pre>
<h2 id="_10">翻转二叉树</h2>
<p>链接：https://leetcode-cn.com/problems/invert-binary-tree/</p>
<h3 id="_11">问题描述</h3>
<p>翻转一棵二叉树。</p>
<p>示例：</p>
<p>输入：</p>
<p>```</p>
<p>​     4</p>
<p>/   \</p>
<p>2     7</p>
<p>/ \   / \</p>
<p>1   3 6   9</p>
<p>```</p>
<p>输出：</p>
<p>```</p>
<p>​     4</p>
<p>/   \</p>
<p>7     2</p>
<p>/ \   / \</p>
<p>9   6 3   1</p>
<p>```</p>
<h3 id="_12">参考答案</h3>
<pre><code class="language-java">`java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
}
</code></pre>
<h2 id="155">15.5 反转链表</h2>
<p>链接：https://leetcode-cn.com/problems/reverse-linked-list/</p>
<h3 id="_13">问题描述</h3>
<p>反转一个单链表。</p>
<p>示例:</p>
<pre><code class="language-java">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<h3 id="_14">参考答案</h3>
<pre><code class="language-java">java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
</code></pre>
<h2 id="lru">LRU缓存机制</h2>
<p>链接：https://leetcode-cn.com/problems/lru-cache/</p>
<h3 id="_15">问题描述</h3>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。</p>
<p>写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p>
<p>进阶:</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<p>示例:</p>
<pre><code class="language-java">LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
</code></pre>
<h3 id="_16">参考答案</h3>
<pre><code class="language-java">java
class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;{
    private int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) {
        return size() &gt; capacity; 
    }
}

/**
 * LRUCache 对象会以如下语句构造和调用:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
</code></pre>
<h2 id="_17">最长回文子串</h2>
<p>链接：https://leetcode-cn.com/problems/longest-palindromic-substring/</p>
<h3 id="_18">问题描述</h3>
<p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p>
<p>示例 1：</p>
<pre><code class="language-java">输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
</code></pre>
<p>示例 2：</p>
<pre><code class="language-java">输入: "cbbd"
输出: "bb"
</code></pre>
<h3 id="_19">参考答案</h3>
<pre><code class="language-java">java
public String longestPalindrome(String s) {
    if (s == null || s.length() &lt; 1) return "";
    int start = 0, end = 0;
    for (int i = 0; i &lt; s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len &gt; end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

private int expandAroundCenter(String s, int left, int right) {
    int L = left, R = right;
    while (L &gt;= 0 &amp;&amp; R &lt; s.length() &amp;&amp; s.charAt(L) == s.charAt(R)) {
        L--;
        R++;
    }
    return R - L - 1;
}
</code></pre>
<h2 id="_20">有效的括号</h2>
<p>链接：https://leetcode-cn.com/problems/valid-parentheses/</p>
<h3 id="_21">问题描述</h3>
<p>给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>
<p>左括号必须用相同类型的右括号闭合。</p>
</li>
<li>
<p>左括号必须以正确的顺序闭合。</p>
</li>
</ol>
<p>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<pre><code class="language-java">输入: "()"
输出: true
</code></pre>
<p>示例 2:</p>
<pre><code class="language-java">输入: "()[]{}"
输出: true
</code></pre>
<p>示例 3:</p>
<pre><code class="language-java">输入: "(]"
输出: false
</code></pre>
<p>示例 4:</p>
<pre><code class="language-java">输入: "([)]"
输出: false
</code></pre>
<p>示例 5:</p>
<pre><code class="language-java">输入: "{[]}"
输出: true
</code></pre>
<h3 id="_22">参考答案</h3>
<pre><code class="language-java">`java
class Solution {

  // Hash table that takes care of the mappings.
  private HashMap&lt;Character, Character&gt; mappings;

  // Initialize hash map with mappings. This simply makes the code easier to read.
  public Solution() {
    this.mappings = new HashMap&lt;Character, Character&gt;();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    // Initialize a stack to be used in the algorithm.
    Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();

    for (int i = 0; i &lt; s.length(); i++) {
      char c = s.charAt(i);

      // If the current character is a closing bracket.
      if (this.mappings.containsKey(c)) {

        // Get the top element of the stack. If the stack is empty, set a dummy value of '#'
        char topElement = stack.empty() ? '#' : stack.pop();

        // If the mapping for this bracket doesn't match the stack's top element, return false.
        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        // If it was an opening bracket, push to the stack.
        stack.push(c);
      }
    }

    // If the stack still contains elements, then it is an invalid expression.
    return stack.isEmpty();
  }
}
</code></pre>
<h2 id="k">数组中的第K个最大元素</h2>
<p>链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</p>
<h3 id="_23">问题描述</h3>
<p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>示例 1:</p>
<pre><code class="language-java">输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
</code></pre>
<p>示例 2:</p>
<pre><code class="language-java">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4
</code></pre>
<p>说明:</p>
<p>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</p>
<h3 id="_24">参考答案</h3>
<pre><code class="language-java">java
import java.util.Random;
class Solution {
  int [] nums;

  public void swap(int a, int b) {
    int tmp = this.nums[a];
    this.nums[a] = this.nums[b];
    this.nums[b] = tmp;
  }

  public int partition(int left, int right, int pivot_index) {
    int pivot = this.nums[pivot_index];
    // 1. move pivot to end
    swap(pivot_index, right);
    int store_index = left;

    // 2. move all smaller elements to the left
    for (int i = left; i &lt;= right; i++) {
      if (this.nums[i] &lt; pivot) {
        swap(store_index, i);
        store_index++;
      }
    }

    // 3. move pivot to its final place
    swap(store_index, right);

    return store_index;
  }

  public int quickselect(int left, int right, int k_smallest) {
    /*
    Returns the k-th smallest element of list within left..right.
    */

    if (left == right) // If the list contains only one element,
      return this.nums[left];  // return that element

    // select a random pivot_index
    Random random_num = new Random();
    int pivot_index = left + random_num.nextInt(right - left); 

    pivot_index = partition(left, right, pivot_index);

    // the pivot is on (N - k)th smallest position
    if (k_smallest == pivot_index)
      return this.nums[k_smallest];
    // go left side
    else if (k_smallest &lt; pivot_index)
      return quickselect(left, pivot_index - 1, k_smallest);
    // go right side
    return quickselect(pivot_index + 1, right, k_smallest);
  }

  public int findKthLargest(int[] nums, int k) {
    this.nums = nums;
    int size = nums.length;
    // kth largest is (N - k)th smallest
    return quickselect(0, size - 1, size - k);
  }
}
</code></pre>
<h2 id="trie">实现 Trie (前缀树)</h2>
<h3 id="_25">问题描述</h3>
<p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<p>示例:</p>
<pre><code class="language-java">Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
</code></pre>
<p>说明:</p>
<p>- 你可以假设所有的输入都是由小写字母 a-z 构成的。</p>
<p>- 保证所有输入均为非空字符串。</p>
<h3 id="_26">参考答案</h3>
<pre><code class="language-java">java
class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
            char currentChar = word.charAt(i);
            if (!node.containsKey(currentChar)) {
                node.put(currentChar, new TrieNode());
            }
            node = node.get(currentChar);
        }
        node.setEnd();
    }

    // search a prefix or whole key in trie and
    // returns the node where search ends
    private TrieNode searchPrefix(String word) {
        TrieNode node = root;
        for (int i = 0; i &lt; word.length(); i++) {
           char curLetter = word.charAt(i);
           if (node.containsKey(curLetter)) {
               node = node.get(curLetter);
           } else {
               return null;
           }
        }
        return node;
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
       TrieNode node = searchPrefix(word);
       return node != null &amp;&amp; node.isEnd();
    }
}
</code></pre>
<h2 id="_27">编辑距离</h2>
<p>链接：https://leetcode-cn.com/problems/edit-distance/</p>
<h3 id="_28">问题描述</h3>
<p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<p>​    \1. 插入一个字符</p>
<p>​    \2. 删除一个字符</p>
<p>​    \3. 替换一个字符</p>
<p>示例 1:</p>
<pre><code class="language-java">输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -&gt; rorse (将 'h' 替换为 'r')
rorse -&gt; rose (删除 'r')
rose -&gt; ros (删除 'e')
</code></pre>
<p>示例 2:</p>
<pre><code class="language-java">输入: word1 = "intention", word2 = "execution"
输出: 5
解释: 
intention -&gt; inention (删除 't')
inention -&gt; enention (将 'i' 替换为 'e')
enention -&gt; exention (将 'n' 替换为 'x')
exention -&gt; exection (将 'n' 替换为 'c')
exection -&gt; execution (插入 'u')
</code></pre>
<h3 id="_29">参考答案</h3>
<pre><code class="language-java">java
class Solution {
  public int minDistance(String word1, String word2) {
    int n = word1.length();
    int m = word2.length();

    // if one of the strings is empty
    if (n * m == 0)
      return n + m;

    // array to store the convertion history
    int [][] d = new int[n + 1][m + 1];

    // init boundaries
    for (int i = 0; i &lt; n + 1; i++) {
      d[i][0] = i;
    }
    for (int j = 0; j &lt; m + 1; j++) {
      d[0][j] = j;
    }

    // DP compute 
    for (int i = 1; i &lt; n + 1; i++) {
      for (int j = 1; j &lt; m + 1; j++) {
        int left = d[i - 1][j] + 1;
        int down = d[i][j - 1] + 1;
        int left_down = d[i - 1][j - 1];
        if (word1.charAt(i - 1) != word2.charAt(j - 1))
          left_down += 1;
        d[i][j] = Math.min(left, Math.min(down, left_down));

      }
    }
    return d[n][m];
  }
}
</code></pre>
<script async="" crossorigin="anonymous" data-category="General" data-category-id="DIC_kwDOILD1rs4CR4oA" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="maomao199691/discuss" data-repo-id="R_kgDOILD1rg" data-strict="0" data-theme="light" src="https://giscus.app/client.js">
</script>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<nav aria-label="Footer" class="md-footer__inner md-grid">
<a aria-label="Previous: 面试说明" class="md-footer__link md-footer__link--prev" href="../%E9%9D%A2%E8%AF%95%E8%AF%B4%E6%98%8E/" rel="prev">
<div class="md-footer__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"></path></svg>
</div>
<div class="md-footer__title">
<div class="md-ellipsis">
<span class="md-footer__direction">
                Previous
              </span>
              面试说明
            </div>
</div>
</a>
<a aria-label="Next: 手写HQL题目练习" class="md-footer__link md-footer__link--next" href="../%E6%89%8B%E5%86%99HQL%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/" rel="next">
<div class="md-footer__title">
<div class="md-ellipsis">
<span class="md-footer__direction">
                Next
              </span>
              手写HQL题目练习
            </div>
</div>
<div class="md-footer__button md-icon">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"></path></svg>
</div>
</a>
</nav>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
<div class="md-copyright__highlight">
      Copyright © 2016 - 2020 Martin Donath
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
<div class="md-social">
<a class="md-social__link" href="https://twitter.com/squidfunk" rel="noopener" target="_blank" title="twitter.com">
<svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.5bf1dace.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
<script src="../../../assets/javascripts/bundle.078830c0.min.js"></script>
<script src="../../../javascripts/mathjax.js"></script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom"});})</script></body>
</html>